<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unsea Browser Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }

        .result {
            background: #f4f4f4;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            word-break: break-all;
        }

        .success {
            color: green;
        }

        .error {
            color: red;
        }

        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #005a87;
        }

        .tabs {
            margin-bottom: 20px;
        }

        .tab-btn {
            background: #eee;
            color: #333;
            border: none;
            padding: 10px 20px;
            border-radius: 5px 5px 0 0;
            margin-right: 2px;
            cursor: pointer;
            font-weight: bold;
        }

        .tab-btn.active {
            background: #007cba;
            color: white;
        }

        .tab-content {
            border: 1px solid #ddd;
            border-top: none;
            padding: 20px;
            border-radius: 0 0 5px 5px;
            background: #fafbfc;
        }
    </style>
</head>

<body>
    <h1>üîê Unsea Browser Example</h1>
    <p>This example demonstrates the Unsea cryptographic toolkit running in a browser with the bundled version.</p>

    <div class="tabs">
        <button class="tab-btn" onclick="showTab('crypto')" id="tab-crypto">Crypto Tests</button>
        <button class="tab-btn" onclick="showTab('session')" id="tab-session">Session Storage</button>
        <button class="tab-btn" onclick="showTab('derive')" id="tab-derive">Key Derivation</button>
    </div>

    <div id="tab-content-crypto" class="tab-content">
        <button onclick="runExample()">Run Cryptographic Tests</button>
        <button onclick="clearOutput()">Clear Output</button>
        <div id="output"></div>
    </div>

    <div id="tab-content-session" class="tab-content" style="display:none;">
        <button onclick="createUserSession()">Create User Sessions</button>
        <button onclick="recallUserSession()">Recall User Sessions</button>
        <button onclick="clearUserSession()">Clear User Sessions</button>
        <button onclick="clearOutput()">Clear Output</button>
        <div id="output-session"></div>
    </div>

    <div id="tab-content-derive" class="tab-content" style="display:none;">
        <h2>üß¨ Key Derivation Test</h2>
        <div style="position:relative; margin-bottom:10px;">
            <textarea id="deriveInput" rows="3" style="width:100%; font-size:1.1em;"
                placeholder="Type your passphrase or random text here..."></textarea>
            <span id="entropyCounter"
                style="position:absolute; top:5px; right:10px; background:#eee; padding:2px 8px; border-radius:12px; font-size:0.9em;">Chars:
                0</span>
        </div>
        <button onclick="deriveKeypair()">Derive Keypair</button>
        <div id="deriveStatus" class="result"></div>
        <div id="deriveResult" class="result"></div>
    </div>

    <script type="module">
        import {
            generateRandomPair,
            signMessage,
            verifyMessage,
            encryptMessageWithMeta,
            decryptMessageWithMeta,
            encryptBySenderForReceiver,
            decryptBySenderForReceiver,
            exportToPEM,
            importFromPEM,
            exportToJWK,
            importFromJWK,
            save,
            recall,
            clear,
            generateWork,
            verifyWork,
            generateSignedWork,
            verifySignedWork,
            derivePair,
            getSecurityInfo
        } from '../dist/unsea.mjs';


        // Tab switching logic
        const TABS = ['crypto', 'session', 'derive'];
        function updateTabUI(tab) {
            const chosen = TABS.includes(tab) ? tab : 'crypto';
            TABS.forEach(t => {
                document.getElementById('tab-content-' + t).style.display = (t === chosen) ? '' : 'none';
                document.getElementById('tab-' + t).classList.toggle('active', t === chosen);
            });
        }
        function getTabFromHash() {
            const h = (location.hash || '').replace('#', '').toLowerCase();
            return TABS.includes(h) ? h : 'crypto';
        }
        function showTab(tab) {
            const target = TABS.includes(tab) ? tab : 'crypto';
            if (location.hash !== '#' + target) {
                location.hash = target;
            } else {
                updateTabUI(target);
            }
        }
        window.addEventListener('hashchange', () => updateTabUI(getTabFromHash()));
        // Initialize from hash (or default)
        updateTabUI(getTabFromHash());

        // Output elements for each tab
        const output = document.getElementById('output');
        const outputSession = document.getElementById('output-session');
        const deriveInput = document.getElementById('deriveInput');
        const entropyCounter = document.getElementById('entropyCounter');
        const deriveStatus = document.getElementById('deriveStatus');
        const deriveResult = document.getElementById('deriveResult');

        // Update log/clearOutput to use correct output div based on tab
        function getActiveOutput() {
            if (!document.getElementById('tab-content-crypto').style.display || document.getElementById('tab-content-crypto').style.display === '') {
                return output;
            } else if (!document.getElementById('tab-content-session').style.display || document.getElementById('tab-content-session').style.display === '') {
                return outputSession;
            }
            return output;
        }
        function log(message, isError = false) {
            const out = getActiveOutput();
            const div = document.createElement('div');
            div.className = `result ${isError ? 'error' : 'success'}`;
            div.innerHTML = message;
            out.appendChild(div);
        }
        function clearOutput() {
            output.innerHTML = '';
            outputSession.innerHTML = '';
        }

        async function runExample() {
            clearOutput();
            log('üöÄ Starting Unsea Browser Tests...');

            try {
                // Test 1: Generate keypairs
                log('1Ô∏è‚É£ Generating keypairs...');
                const alice = await generateRandomPair();
                const bob = await generateRandomPair();
                log(`Alice's public key: ${alice.pub.substring(0, 30)}...`);
                log(`Bob's public key: ${bob.pub.substring(0, 30)}...`);

                // Test 2: Sign and verify
                log('2Ô∏è‚É£ Testing message signing...');
                const message = "Hello from browser! This is a test message.";
                const signature = await signMessage(message, alice.priv);
                const isValid = await verifyMessage(message, signature, alice.pub);
                log(`Message: "${message}"`);
                log(`Signature: ${signature.substring(0, 30)}...`);
                log(`Verification: ${isValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);

                // Test 3: Encrypt and decrypt
                log('3Ô∏è‚É£ Testing message encryption...');
                const secretMessage = "This is a secret message! üîí";
                const encrypted = await encryptMessageWithMeta(secretMessage, bob);
                const decrypted = await decryptMessageWithMeta(encrypted, bob.epriv);
                log(`Original: "${secretMessage}"`);
                log(`Encrypted: ${encrypted.ciphertext.substring(0, 30)}...`);
                log(`Decrypted: "${decrypted}"`);
                log(`Match: ${secretMessage === decrypted ? '‚úÖ Success' : '‚ùå Failed'}`);

                // Test 4: Proof of Work
                log('4Ô∏è‚É£ Testing Proof of Work...');
                const challengeData = {
                    challenge: "Browser proof of work test",
                    timestamp: Date.now()
                };
                const work = await generateWork(challengeData, 3, 50000);
                const workValid = await verifyWork(work);
                log(`Challenge: ${JSON.stringify(challengeData)}`);
                log(`Nonce: ${work.nonce}`);
                log(`Hash: ${work.hashHex}`);
                log(`Duration: ${work.duration}ms`);
                log(`Verification: ${workValid.valid ? '‚úÖ Valid' : '‚ùå Invalid'}`);

                // Test 5: Signed Proof of Work
                log('5Ô∏è‚É£ Testing Signed Proof of Work...');
                const signedChallengeData = {
                    challenge: "Browser signed proof test",
                    user: alice.pub.substring(0, 20) + '...',
                    timestamp: Date.now()
                };
                const signedWork = await generateSignedWork(signedChallengeData, alice.priv, 3, 25000);
                const signedVerification = await verifySignedWork(signedWork, alice.pub);
                log(`Signed Challenge: ${JSON.stringify(signedChallengeData)}`);
                log(`Nonce: ${signedWork.nonce}`);
                log(`Hash: ${signedWork.hashHex}`);
                log(`Duration: ${signedWork.duration}ms`);
                log(`Signature Valid: ${signedVerification.signatureValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);
                log(`Work Valid: ${signedVerification.workValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);
                log(`Overall Valid: ${signedVerification.valid ? '‚úÖ Valid' : '‚ùå Invalid'}`);

                // Test 6: Key formats
                log('6Ô∏è‚É£ Testing key format conversion...');
                const pemKey = await exportToPEM(alice.priv);
                const importedFromPem = await importFromPEM(pemKey);
                const jwkKey = await exportToJWK(alice.priv);
                const importedFromJwk = await importFromJWK(jwkKey);
                log(`PEM export/import: ${alice.priv === importedFromPem ? '‚úÖ Success' : '‚ùå Failed'}`);
                log(`JWK export/import: ${alice.priv === importedFromJwk ? '‚úÖ Success' : '‚ùå Failed'}`);

                // Test 7: Security Information
                log('7Ô∏è‚É£ Displaying Security Information...');
                const securityInfo = getSecurityInfo();
                log(`Library Version: ${securityInfo.version}`);
                log(`Signing Algorithm: ${securityInfo.algorithms.signing}`);
                log(`Encryption Algorithm: ${securityInfo.algorithms.encryption}`);
                log(`Security Enhancements: ${securityInfo.securityEnhancements.length} items`);

                log('üéâ All browser tests completed successfully!');

            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        async function createUserSession() {
            clearOutput();
            log('üöÄ Testing Session Storage Functions (like Gun\'s user.recall())...');

            try {
                // Generate a test keypair
                log('1Ô∏è‚É£ Generating test keypair...');
                const testUser = await generateRandomPair();
                log(`Generated keypair for testing`);
                log(`Public key: ${testUser.pub.substring(0, 30)}...`);

                // Test save function
                log('2Ô∏è‚É£ Saving keypair to session storage...');
                const saveResult = save(testUser, 'testUser');
                log(`Save result: ${saveResult ? '‚úÖ Success' : '‚ùå Failed'}`);


                // Test saving multiple users
                log('5Ô∏è‚É£ Testing multiple user sessions...');
                const alice = await generateRandomPair();
                const bob = await generateRandomPair();

                save(alice, 'alice');
                save(bob, 'bob');
                log('Saved Alice and Bob keypairs');


            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        async function recallUserSession() {
            clearOutput();
            log('üöÄ Testing Session Storage Functions (like Gun\'s user.recall())...');

            try {

                // Test recall function
                log('3Ô∏è‚É£ Recalling keypair from session storage...');
                const recalledUser = recall('testUser');
                if (recalledUser) {
                    log(`‚úÖ Recall successful!`);
                    log(`Public key: ${recalledUser.pub}`);
                    log(`Private key: ${recalledUser.priv}`);

                    // Test functionality with recalled keypair
                    log('4Ô∏è‚É£ Testing recalled keypair functionality...');
                    const testMessage = 'Testing recalled keypair signing';
                    const signature = await signMessage(testMessage, recalledUser.priv);
                    const isValid = await verifyMessage(testMessage, signature, recalledUser.pub);
                    log(`Signature with recalled keypair: ${isValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);
                } else {
                    log('‚ùå Recall failed');
                    return;
                }

                const recalledAlice = recall('alice');
                const recalledBob = recall('bob');
                log(`Alice recalled: ${recalledAlice ? '‚úÖ Success' : '‚ùå Failed'}`);
                log(`Bob recalled: ${recalledBob ? '‚úÖ Success' : '‚ùå Failed'}`);
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        async function clearUserSession() {
            clearOutput();
            log('üöÄ Testing Session Storage Functions (like Gun\'s user.recall())...');

            try {

                // Test clear function
                log('6Ô∏è‚É£ Testing clear function...');
                const clearResult = clear('testUser');
                log(`Clear testUser: ${clearResult ? '‚úÖ Success' : '‚ùå Failed'}`);

                const clearedRecall = recall('testUser');
                log(`testUser cleared: ${clearedRecall === null ? '‚úÖ Success' : '‚ùå Still exists'}`);

                // Clear all UnSEA data
                log('7Ô∏è‚É£ Clearing all UnSEA session data...');
                clear(null); // Clear all
                const aliceAfterClear = recall('alice');
                const bobAfterClear = recall('bob');
                log(`All data cleared: ${aliceAfterClear === null && bobAfterClear === null ? '‚úÖ Success' : '‚ùå Failed'}`);

                log('üéâ Session storage tests completed successfully!');
                log('üí° Keypairs are now stored in your browser session - refresh to test persistence!');

            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        function updateEntropyCounter() {
            const val = deriveInput.value;
            const entropy = val.length;
            entropyCounter.textContent = `Chars: ${entropy}`;
            if (entropy < 16) {
                entropyCounter.style.background = '#ffd6d6';
                deriveStatus.className = 'result error';
                deriveStatus.textContent = '‚ùå Not enough characters (min 16 recommended)';
            } else {
                entropyCounter.style.background = '#d6ffd6';
                deriveStatus.className = 'result success';
                deriveStatus.textContent = '‚úÖ Sufficient length';
            }
            deriveResult.textContent = '';
        }
        deriveInput && deriveInput.addEventListener('input', updateEntropyCounter);
        if (deriveInput) updateEntropyCounter();

        async function deriveKeypair() {
            const val = deriveInput.value;
            const entropy = val.length;
            if (entropy < 16) {
                deriveStatus.className = 'result error';
                deriveStatus.textContent = '‚ùå Not enough characters to derive a secure keypair!';
                deriveResult.textContent = '';
                return;
            }
            deriveStatus.className = 'result success';
            deriveStatus.textContent = '‚è≥ Deriving keypair...';
            try {
                const keypair = await derivePair(val);
                deriveResult.className = 'result success';
                deriveResult.innerHTML = `<b>Derived Keypair:</b><br>pub: <code>${keypair.pub}</code><br>priv: <code>${keypair.priv}</code><br>epub: <code>${keypair.epub}</code><br>epriv: <code>${keypair.epriv}</code>`;
                deriveStatus.textContent = '‚úÖ Keypair derived successfully!';
            } catch (e) {
                deriveResult.className = 'result error';
                deriveResult.textContent = '‚ùå Error: ' + e.message;
                deriveStatus.textContent = '‚ùå Derivation failed';
            }
        }

        // expose handlers for inline onclick attributes
        window.showTab = showTab;
        window.runExample = runExample;
        window.createUserSession = createUserSession;
        window.recallUserSession = recallUserSession;
        window.clearUserSession = clearUserSession;
        window.deriveKeypair = deriveKeypair;
        window.clearOutput = clearOutput;
    </script>
</body>

</html>